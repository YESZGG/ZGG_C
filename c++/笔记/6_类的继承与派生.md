## 类的继承与派生

#### 一、类的组合

类的组合是指在一个类中使用其他类的对象作为成员变量，以创建更复杂的数据结构或实现更高级的功能。这种关系称为"`has-a`"关系，其中一个类包含了另一个类的对象。

**特点：**
- 类的组合关系可以创建更强大、更灵活的类。
- 通过将不同的类组合在一起，可以实现模块化和可重用的代码。
- 组合关系可以定义逻辑上相关的类之间的依赖关系，并提供更好的封装和信息隐藏。
- 具备组合关系的类可以通过调用其成员对象的方法来实现相关操作。

**规则：**
- 成员对象在类的声明中作为另一个类的对象进行声明，通常在类的构造函数中初始化。
- 成员对象的生命周期由包含它的类管理。
- 使用组合关系时，应注意类之间的耦合度，避免出现循环引用或过渡复杂的关系。

**应用：**
- 组合关系广泛应用于面向对象编程，用于构建复杂的数据结构和系统。
- 在图形界面编程中，可以使用组合关系构建窗口、控件等复杂的用户界面。
- 在游戏开发中，可以使用组合关系构建角色、场景等游戏对象。
- 在企业软件开发中，可以使用组合关系构建员工、部门等组织结构。

示例代码：

```cpp
class Engine {
public:
    void Start() {
        std::cout << "Engine started!" << std::endl;
    }
};

class Car {
private:
    Engine engine;

public:
    void StartEngine() {
        engine.Start();
    }
};

int main() {
    Car myCar;
    myCar.StartEngine();

    return 0;
}
```

在上述示例中，定义了两个类 `Engine` 和 `Car`。`Engine` 类表示汽车的引擎，而 `Car` 类中包含一个 `Engine` 对象作为成员变量。在 `Car` 类的 `StartEngine()` 方法中，调用了 `engine` 成员对象的 `Start()` 方法来启动引擎。

在 `main()` 函数中，创建了一个 `Car` 对象并调用其 `StartEngine()` 方法，该方法通过调用成员对象 `engine` 的方法来模拟启动汽车引擎。

#### 类的继承


类的继承是一种面向对象编程中的重要概念，用于创建新的类并从现有类派生。通过继承，一个类可以获得另一个类的属性和行为，以便重用和扩展现有代码。

**作用：**
- 继承允许创建一个通用、抽象的基类，并从该基类派生出具体的子类，在子类中添加特定的属性和行为。
- 通过继承，可以实现代码的模块化和可重用性，减少代码重复和冗余。
- 继承提供了多态性的基础，可以在不同的子类对象上调用相同的方法，以实现不同的行为。

**特点：**
- 子类拥有基类的所有非私有成员（成员变量和成员函数），包括公有、保护和被继承类自身定义的私有成员。
- 子类可以添加自己的额外成员变量和成员函数。
- 子类可以覆盖（重写）基类的成员函数，以定制自己特定的行为。
- 通过继承链，可以建立多层次的继承关系，形成类的层次结构。

**语法规则：**
在 C++ 中，使用 `class` 或 `struct` 关键字来定义派生类，并使用 `:` 运算符指定基类。语法示例如下：

```cpp
class Base {
    // Base class definition
};

class Derived : access-specifier Base {
    // Derived class definition
};
```

在 `access-specifier` 中，可以指定派生类对基类成员的访问权限。常用的三个访问控制符为：
- `public`: 基类的 `public` 成员在派生类中仍然保持为 `public` 访问权限。
- `protected`: 基类的 `public` 成员在派生类中变为 `protected` 访问权限。
- `private`: 基类的 `public` 成员在派生类中变为 `private` 访问权限。

**应用：**
- 继承广泛应用于面向对象编程，用于创建类的层次结构和代码重用。
- 通过继承可以建立不同类之间的关系，比如一个基类表示动物，派生出狗、猫等子类。
- 继承也可用于实现接口和抽象类，定义一组规范供其他类进行继承和实现。

示例代码：

```cpp
#include <iostream>

class Animal {
protected:
    std::string name;

public:
    Animal(const std::string& animalName) : name(animalName) {}

    void speak() const {
        std::cout << "I am an animal." << std::endl;
    }
};

class Dog : public Animal {
public:
    Dog(const std::string& dogName) : Animal(dogName) {}

    void speak() const {
        std::cout << "I am a dog named " << name << "." << std::endl;
        Animal::speak();  // 调用基类的成员函数
    }
};

int main() {
    Dog myDog("Buddy");
    myDog.speak();

    return 0;
}
```

在上述示例中，定义了一个 `Animal` 类作为基类，拥有一个保护级别的成员变量 `name` 和一个公有成员函数 `speak()`。然后，通过派生类 `Dog` 继承了 `Animal` 类，并添加了自己的成员函数 `speak()`。

在 `main()` 函数中，创建了一个 `Dog` 对象 `myDog`，并调用了它的 `speak()` 函数。输出将显示狗的名字以及基类和派生类的信息。

总结而言，类的继承提供了创建新的类并从现有类派生的一种机制。通过继承，可以实现代码的模块化、可重用性和多态性。继承具有特定的语法规则，允许派生类获得基类的属性和行为，并自定义自己的成员变量和成员函数。继承广泛应用于面向对象编程中，用于构建类的层次结构和实现代码的重用和扩展。

--------------------------------------------------------------

##### 子类的大小
规则：子类的大小=父类数据成员的和+子类本身数据成员的和（也要满足字节对齐）

--------------------------------------------------------------

#### 访问控制和继承
派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。

我们可以根据访问权限总结出不同的访问类型，如下所示：


|   访问   | public | protected | private |
| :------: | :----: | :-------: | :------ |
| 同一个类 |  yes   |    yes    | yes     |
|  派生类  |  yes   |    yes    | no      |
| 外部的类 |  yes   |    no     | no      |

**一个派生类继承了所有的基类方法，但下列情况除外：**

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

 -------------------------------------------------------------

#### 继承类型

当一个类派生自基类，该基类可以被继承为 `public`、`protected` 或 `private` 几种类型。继承类型是通过上面讲解的访问修饰符 `access-specifier` 来指定的。

我们几乎不使用 `protected` 或 `private` 继承，通常使用` public` 继承。当使用不同类型的继承时，遵循以下几个规则：

- 公有继承（`public`）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。

- 保护继承（`protected`）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
- 私有继承（`private`）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

