
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [虚继承](#虚继承)
- [虚函数](#虚函数)
    - [如何证明虚函数是在虚表上的 ? ? ?](#如何证明虚函数是在虚表上的---)
- [隐藏与覆盖](#隐藏与覆盖)

<!-- /code_chunk_output -->


## 虚继承
**虚继承的概念**

虚继承是面向对象编程中的一个概念，用于解决多重继承时可能引发的问题。当一个类需要从多个基类派生而来，并且这些基类之间存在共同的基类时，使用虚继承可以避免出现数据冗余和二义性。

**虚继承的语法格式**

虚继承通过在派生类声明中使用关键字`virtual`来实现。语法格式如下：

```cpp
class DerivedClass : virtual access-specifier BaseClass {
    // DerivedClass 的成员和函数定义
};
```

这里的`access-specifier`表示访问控制修饰符，可以是`public`、`protected`或`private`。

**虚继承的特点特性**

- 虚继承保证只有一份共同基类的实例存在于派生类对象中，避免了数据的冗余。
- 当通过虚基类进行派生的各个子类共享某个虚基类对象时，虚基类的构造函数只会被调用一次，确保了对共享对象的正确初始化。
- 虚继承解决了菱形继承（钻石继承）问题，即当两个基类通过不同的路径最终继承到同一个派生类时，虚继承可以避免产生二义性。

**什么时候使用虚继承**

虚继承通常在以下两种情况下使用：

1. 菱形继承（钻石继承）问题：当一个类需要从多个基类继承而来，并且这些基类之间存在共同的基类时，使用虚继承可以避免数据的冗余和二义性。
2. 需要实现多继承时：虚继承允许派生类共享一个公共基类对象，确保只有一份共享对象存在。

**示例**

下面是一个使用虚继承的示例。假设有一个基类`Animal`，它有两个派生类`Dog`和`Cat`，而这两个派生类又共享一个基类`Mammal`。使用虚继承可以解决`Dog`和`Cat`中对`Mammal`的冗余继承。

```cpp
class Mammal {
protected:
    int numLegs;
public:
    Mammal(int legs) : numLegs(legs) {}
};

class Animal {
    // Animal 类的定义
};

class Dog : virtual public Mammal, virtual public Animal {
    // Dog 类的定义
};

class Cat : virtual public Mammal, virtual public Animal {
    // Cat 类的定义
};
```

上述示例中，`Dog`和`Cat`通过虚继承分别继承了`Mammal`和`Animal`。由于使用了虚继承，每个`Dog`或`Cat`对象只包含一份`Mammal`和`Animal`的成员变量，避免了数据的冗余。

**当C++中含有虚方法时，系统就会产生一个虚表，所有的虚方法都放入该虚表中，当虚表存在同名的方法时，就会产生一个覆盖的特性。**

在 C++ 中存在虚函数时，对应的每个类（包括基类和派生类）都会有一个**虚表**（也称为虚函数表或vtable）。**虚表是一个指向虚函数的指针数组，用于实现动态多态性。**

当一个类声明了虚函数时，编译器会自动生成虚表，并将虚函数的地址存储到虚表中相应的位置。派生类会继承虚表，并可以覆盖（重写）基类的虚函数，即在派生类中重新定义同名的虚函数。

通过虚表的机制，C++ 在运行时能够根据对象的实际类型来决定调用哪个虚函数。这就实现了多态性，可以在程序运行时根据对象的具体类型决定调用哪个版本的虚函数，而不仅仅局限于静态类型。

需要注意的是，虚表是针对每个类的，在每个类的对象中，会有一个指向其所属类的虚表的指针（称为虚指针或vptr），**当类中存在虚函数时，虚表的地址就是类的第一个数据成员首地址**，用于在运行时动态选择适当的虚表。还要注意的是，虚函数的调用会带来额外的开销，因为需要通过虚指针和虚表进行间接调用。

这种基于虚表的特性使得 C++ 能够实现动态多态，提供了很强的灵活性和扩展性。


## 虚函数
**概念：**
虚函数是在C++中用于实现多态的一种机制。通过将基类中的函数声明为虚函数，可以在派生类中进行覆盖，根据对象的实际类型来决定调用哪个版本的函数。

**特点：**
- 虚函数需要在基类中进行声明，并且在派生类中进行重写（覆盖）。
- 使用关键字`virtual`来标识虚函数。
- 虚函数通过动态绑定实现了运行时的多态性。
- 虚函数只能通过指针或引用调用，而不能通过对象直接调用。

**作用：**
虚函数的主要作用是实现运行时的多态性，让程序能够根据对象的实际类型来确定所调用的函数版本。这样可以编写通用的代码，通过基类指针或引用来操作派生类对象，并在运行时动态地选择正确的函数执行。

**什么时候应用虚函数：**
应用虚函数的情况包括：
- 当需要处理具有不同子类型的对象集合时，可以使用基类指针或引用来操作这些对象，并利用虚函数实现多态性。
- 当希望派生类能够重新定义基类中的函数，以适应派生类自身的需求时，可以将基类函数声明为虚函数，并在派生类中进行重写（覆盖）。
- 当需要在运行时根据对象的实际类型选择正确的函数版本时，可以使用虚函数来实现动态绑定。

简而言之，应用虚函数最常见的情况是处理多个相关的类，并希望通过基类指针或引用来使用这些类，以及实现多态性和动态绑定的需求。


#### 如何证明虚函数是在虚表上的 ? ? ?

```cpp
#include <iostream>
using namespace std;

class base
{
private:
    // 所有的虚函数都放在虚表上
    virtual void f()
    {
        cout << "show f" << endl;
    }
    virtual void j()
    {
        cout << "show j" << endl;
    }
    virtual void k()
    {
        cout << "show k" << endl;
    }
};

int main()
{
    base tmp;

    /*
    在VS中，long是4字节，32位。 -2147483648~2147483647
    在Linux中，long是8字节，64位。-9223372036854775808~9223372036854775807
    C++11标准增了long long类型的整数，至少64位，且至少与long一样长。
    在VS中，long long是8字节，64位。-9223372036854775808~9223372036854775807
    在Linux中，long和long long类型都是8字节，64位。
    */
    cout << sizeof(long) << endl;      // 8个字节
    cout << sizeof(long long) << endl; // 8个字节

    // 获取类的首地址 与 虚表指针的地址一样
    cout << "&tmp=" << &tmp << endl;

    // 虚表指针的地址 p  保存 虚表指针的地址
    long long *p = (long long *)&tmp;

    // 取该地址上内容
    long long *v_table = (long long *)*p;

    cout << "虚表地址v_table=" << v_table << endl;

    // 定义一个函数指针
    typedef void (*func)(); //定义了一个名为 func 的函数指针类型

    // 得到第一个虚函数的地址
    func f = (func)v_table[0]; // 给函数指针赋值 函数名字即是函数指针的地址
    // 调用函数
    f();

    f = (func)v_table[1]; // 给函数指针赋值 函数名字即是函数指针的地址
    // 调用函数
    f();

    f = (func)v_table[2]; // 给函数指针赋值 函数名字即是函数指针的地址
    // 调用函数
    f();
}
```

## 隐藏与覆盖

在 C++ 中，隐藏和覆盖是两种不同的概念，用于描述派生类成员函数与基类成员函数之间的关系。


**隐藏（Hide）**

当**派生类中**定义了与**基类**中**同名的成员函数**时，**派生类的成员函数会隐藏基类的同名函数**，这被称为隐藏。在隐藏发生时，无论通过基类指针还是派生类指针访问成员函数，都只能访问到定义了的成员函数。

下面是一个隐藏的示例：

```cpp
class Base {
public:
    void show() {
        cout << "Base::show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() {
        cout << "Derived::show()" << endl;
    }
};

int main() {
    Derived d;
    d.show();         // Derived::show()
    d.Base::show();   // Base::show() - 通过作用域解析运算符可以访问基类函数
    return 0;
}
```

在上述示例中，派生类 `Derived` 定义了一个同名的函数 `show()`，它隐藏了基类 `Base` 的 `show()` 函数。在 `main()` 函数中，使用派生类对象访问 `show()` 函数时，会调用派生类的函数。如果需要访问基类的函数，可以通过作用域解析运算符 `::` 显式地指定使用基类的函数。

**覆盖（Override）**

当派生类中的同名函数与基类函数属于**多态关系**时，派生类可以使用 `override` 关键字来明确标注它在派生类中是一个被覆盖（重写）的函数。通过覆盖，派生类可以重新定义基类的虚函数，实现特定的行为。

当基类含有**虚函数**，派生类中重写了一个**同名同参的函数**，那么派生类就会把基类的虚函数给**覆盖(重写)**

下面是一个覆盖的示例：

```cpp
class Base {
public:
    virtual void show() {
        cout << "Base::show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show()" << endl;
    }
};

int main() {
    Derived d;
    Base* b = &d;
    b->show();  // Derived::show() - 多态调用派生类函数
    return 0;
}
```

在上述示例中，基类 `Base` 的 `show()` 函数被声明为虚函数，并且在派生类 `Derived` 中被覆盖。在 `main()` 函数中，通过基类指针调用虚函数 `show()` 时发生了多态调用，因此会动态地调用派生类的函数。

总结起来，隐藏是指派生类成员函数隐藏了基类同名函数，而覆盖是指在派生类中重新定义了基类的虚函数，以实现不同的行为。隐藏只影响同名函数的可见性，而覆盖能够实现多态调用。两者都是 C++ 中用于处理派生类与基类之间成员函数关系的重要概念。


