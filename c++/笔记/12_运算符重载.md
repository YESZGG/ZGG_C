# 运算符重载
重载就是赋予一个实物新的功能，重新载入，更新。以往的运算符只支持，基本的数据类型操作`(char,short,int,fioat..)`，无法操作用户自定义的数据类型`(struct student,char buf[1024])`，这时候我们就要利用运算符重载赋予该运算符新的功能。
#### 运算符重载的定义
运算符重载是指通过定义类的成员函数或全局函数，为已有的运算符赋予新的含义或功能。

#### 语法格式：
```cpp
返回类型 operator 运算符 (参数列表) {
    // 实现运算符重载的代码
}
```
**运算符函数可以作为成员函数或非成员函数进行重载 。**

作用：
1. 提供更自然的语法和更直观的操作，使得类对象可以像内置类型一样进行运算。
2. 增加代码的可读性和可维护性，使得代码更易于理解和使用。
3. 可以根据类的特性和需求，自定义运算符的行为，实现更灵活的功能。

特点：
1. 运算符重载是C++中的一项重要特性，可以使得类对象的使用更加直观和方便。
2. 运算符重载可以应用于内置类型和自定义类型，使得自定义类型的操作更像内置类型。
3. 运算符重载可以是成员函数形式或全局函数形式，根据需要选择合适的形式。
4. 运算符重载的函数名必须以`operator`关键字开头，后面跟着要重载的运算符。

#### 可重载运算符/不可重载运算符
下面是可重载的运算符列表：

| 双目算术运算符 | `+` (加)，`-` (减)，`*` (乘)，`/` (除)，`%` (取模) |
| :------------: | :------------------------ |
| 关系运算符   | `==` (等于)，`!=` (不等于)，`<` (小于)，`>` (大于)，`<=` (小于等于)，`>=` (大于等于) |
| 逻辑运算符   | `||` (逻辑或)，`&&` (逻辑与)，`!` (逻辑非) |
| 单目运算符   | `+` (正)，`-` (负)，`*` (指针)，`&` (取地址) |
| 自增自减运算符 | `++` (自增)，`--` (自减) |
| 位运算符     | `|` (按位或)，`&` (按位与)，`~` (按位取反)，`^` (按位异或), `<<` (左移), `>>` (右移) |
| 赋值运算符   | `=`，`+=`，`-=`，`*=`，`/=`，`%=`，`&=`，`|=`，`^=`，`<<=`，`>>=` |
| 空间申请与释放 | `new`，`delete`，`new[]`，`delete[]` |
| 其他运算符   | `()` (函数调用)，`->` (成员访问)，`,` (逗号)，`[]`(下标) |

下面是不可重载的运算符列表：

`.`：成员访问运算符
`.*`, `->*`：成员指针访问运算符
`::`：域运算符
`sizeof`：长度运算符
`?:`：条件运算符
`#`： 预处理符号


以下是一个运算符重载的示例代码，演示了如何重载加法运算符：

```cpp
#include <iostream>

class Complex {
private:
    double real;
    double imag;

public:
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    Complex operator+(const Complex& c) {
        Complex result;
        result.real = this->real + c.real;
        result.imag = this->imag + c.imag;
        return result;
    }

    void display() {
        std::cout << real << " + " << imag << "i" << std::endl;
    }
};

int main() {
    Complex c1(1.0, 2.0);
    Complex c2(3.0, 4.0);
    Complex c3 = c1 + c2;

    c3.display();

    return 0;
}
```

在上述代码中，通过重载加法运算符`+`，使得两个Complex对象可以直接相加，得到新的Complex对象。运算符重载的函数`operator+`被定义为类的成员函数，用于实现加法运算符的功能。


